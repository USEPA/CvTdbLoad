---
title: "Querying CvTdb"
description: >
  The following is a guide for querying the Concentration versus Time (CvT) database.
  This includes sample queries and example cases.
resource_files:
  - images/CvTdb_EER.jpg
output: html_document
vignette: >
  %\VignetteIndexEntry{Querying CvTdb}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
library(DT)
# https://stackoverflow.com/questions/37755037/how-to-add-code-folding-to-output-chunks-in-rmarkdown-html-documents
# https://stackoverflow.com/questions/56550878/in-r-markdown-how-to-output-sortable-table-while-r-chunk-is-set-to-results-a
```

## Getting Started
### Credential Security
One of the most important considerations to make when programmatically accessing databases is how to secure your database credentials. **NEVER HARDCODE CREDENTIALS**. Each programming language provides means to externalize such information and bring it into the environment. For `R`, the `.Renviron` file is where you can store your database connection credentials to then be used by the script.

> **Note:** When using online repositories like `GitHub` or `Bitbucket`, be sure to configure your `.gitignore` files appropriately so that your externalized credentials files (e.g., `.Renviron`, `.env`, etc.) are not uploaded with your code. An example .gitignore for `R` code has been provided. See [here](https://github.com/github/gitignore) for additional examples across coding languages.

### Querying Databases
Queries can be made either by using pure SQL (as with the example `query_cvt()` helper function), or through dplyr notation (see [dplyr]( https://db.rstudio.com/r-packages/dplyr/) and [tidyverse](https://dbplyr.tidyverse.org/) for additional information).

### Database Schema Diagrams
The EER diagram shows how the tables are linked together, which help with join queries.
See [here](https://www.lucidchart.com/pages/ER-diagram-symbols-and-meaning) for help in reading the diagram.

### CvTdb EER Diagram
```{r out.height = "400px", out.width = "400px", echo = FALSE}
knitr::include_graphics("images/CvTdb_EER.jpg")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

if(!file.exists("res_cvtdb.sqlite")){
  if(!file.exists("../output/release/res_cvtdb.sqlite")){
    get_cvtdb_sqlite("cvt", outdir=getwd())
  }
  file.copy("../output/release/res_cvtdb.sqlite", "res_cvtdb.sqlite")
}
```

### Load required packages
```{r}
library(DBI)
library(dplyr)
library(dbplyr)
```

### Helper Functions for Connecting and Querying the Database
<details><summary>Click to view functions</summary>
```{r}
#'@description A function to make a connection to the database
#'@param con_type Whether to connect to postgres, mysql, or sqlite version
#'@import DBI RMySQL RSQLite
#'@return Database connection pointer object
connect_to_db <- function(con_type){
  switch(con_type,
         "postgres" = dbConnect(RPostgres::Postgres(), 
                                user = Sys.getenv("postgres_user"), 
                                password = Sys.getenv("postgres_pass"), #
                                host = Sys.getenv("postgres_host"), #
                                dbname = Sys.getenv("postgres_dbname")),
         "mysql" = dbConnect(RMySQL::MySQL(), #Connect to database with .Renviron parameters
                             username = Sys.getenv("mysql_user"), 
                             password = Sys.getenv("mysql_pass"),
                             host = Sys.getenv("mysql_host"), 
                             port = 3306,
                             dbname = Sys.getenv("mysql_dbname")),
         'sqlite' = dbConnect(RSQLite::SQLite(), paste0(Sys.getenv("sqlite_dbname"), ".sqlite"))
  ) %>% return()
}

#'@description A helper function to query database and receive the results. 
#'Handles errors/warnings with tryCatch.
#'@param query A SQL query string to query the database with
#'@param con_type Whether to connect to postgres, mysql, or sqlite version
#'@param schema The schema name to use if using a postgresql connection
#'@import DBI dplyr
#'@return Dataframe of database query results
query_db <- function(query=NULL, con_type, schema){
  if(is.null(query)) return(cat("\nMust provide a query to send"))
  con = connect_to_db(con_type)
  
  query_result = tryCatch({
    if(con_type == "postgres"){# Add schema tag
      return(dbGetQuery(con, query %>% 
                          gsub("FROM ", paste0("FROM ",schema,"."), .) %>%
                          gsub("JOIN ", paste0("JOIN ",schema,"."), .)
                        ))
    } else {
      return(dbGetQuery(con, query))
    }
  },
  error=function(cond){ cat(paste0("\nError message: ", cond)); return(NULL) },
  finally={ dbDisconnect(con) })
  
  return(query_result)
}

compare_sql_dbplyr <- function(){
  if(exists("df_sql") && exists("df_dbplyr")){
    ifelse(identical(df_sql, df_dbplyr), 
                 "SQL and dplyr version outputs are identical", 
                 "SQL and dplyr version outputs are NOT identical")
    }
}
```
<details>

## Sample Queries
```{r, echo = FALSE}
query <- "SELECT pmid, year, first_author, title FROM documents LIMIT 15"
df_sql <- query_db(query = query, con_type = "sqlite")
```

```{r, echo = FALSE}

con <- connect_to_db(con_type = "sqlite")

# Wrapped in a tryCatch so the connection is always closed in case of error
df_dbplyr <- tryCatch(
  {
    tbl(con, "documents") %>%
      head(15) %>%
      select(pmid, year, first_author, title) %>%
      collect() %>%
      as.data.frame()
  },
  error=function(e) {
    message(e)
    return(NULL)
  },
  finally={
    dbDisconnect(con)
  }
)
```

### Loading CvTdb Documents Table {.tabset}
```{r, echo = FALSE}
compare = compare_sql_dbplyr()
```
`r toString(compare)`

#### df_sql

    query <- "SELECT pmid, year, first_author, title FROM documents LIMIT 15"
    df_sql <- query_db(query = query, con_type = "sqlite")

`r DT::datatable(df_sql, list(scrollX = TRUE))`

#### df_dbplyr

    con <- connect_to_db(con_type = "sqlite")

    # Wrapped in a tryCatch so the connection is always closed in case of error
    df_dbplyr <- tryCatch(
      {
    tbl(con, "documents") %>%
      head(15) %>%
      select(pmid, year, first_author, title) %>%
      collect() %>%
      as.data.frame()
      },
      error=function(e) {
        message(e)
        return(NULL)
      },
      finally={
        dbDisconnect(con)
      }
    )
    
`r DT::datatable(df_dbplyr, list(scrollX = TRUE))`

### {-}


### Pull all data by input document identifier {.tabset}

```{r, echo = FALSE}
# PMID list of interest
pmid_list <- c('43370', '422270', '422271', '538758', '629888', '731724', '734422', '843463', '843464', '926203')
                # Select columns of interest
query <- paste0("SELECT distinct e.pmid, b.analyte_name_original, c.dose_level_original, c.dose_level_units_original, ",
                "d.species, b.conc_medium_original, a.time_original, b.time_units_original, a.conc_original, b.conc_units_original ",
                "FROM conc_time_values a ",
                # Join to series table by series ID
                "LEFT JOIN series b on b.id = a.fk_series_id ",
                # Join to studies table by study ID
                "LEFT JOIN studies c on c.id = b.fk_study_id ",
                # Join to subjects table by subject ID
                "LEFT JOIN subjects d on d.id = b.fk_subject_id ",
                # Join to documents table by extraction document ID
                "LEFT JOIN documents e on c.fk_extraction_document_id = e.id ",
                # Filter to PMID of interest
                "WHERE e.pmid in ('",
                # Using paste instead of toString() for cases where identifiers
                # are alphanumeric strings
                paste0(pmid_list, collapse="', '"),
                "')")
df_sql <- query_db(query = query, 
               con_type = "sqlite")
```

```{r, echo = FALSE}
con <- connect_to_db(con_type = "sqlite")

# Wrapped in a tryCatch so the connection is always closed in case of error
df_dbplyr <- tryCatch(
  {
    # Store table pointers with column name prefixes
    conc = tbl(con, "conc_time_values") %>% rename_all(function(x) paste0("a.", x))
    series = tbl(con, "series") %>% rename_all(function(x) paste0("b.", x))
    studies = tbl(con, "studies") %>% rename_all(function(x) paste0("c.", x))
    subjects = tbl(con, "subjects") %>% rename_all(function(x) paste0("d.", x))
    docs = tbl(con, "documents") %>% rename_all(function(x) paste0("e.", x))
    
    out <- conc %>%
      left_join(series, 
                by=c("a.fk_series_id"="b.id")) %>%
      left_join(studies, 
                by=c("b.fk_study_id"="c.id")) %>%
      left_join(subjects, 
                by=c("b.fk_subject_id"="d.id")) %>%
      left_join(docs, 
                by=c("c.fk_extraction_document_id"="e.id")) %>%
      filter(e.pmid %in% pmid_list) %>%
      select(e.pmid, b.analyte_name_original, c.dose_level_original, 
             c.dose_level_units_original, d.species, b.conc_medium_original, 
             a.time_original, b.time_units_original, a.conc_original, b.conc_units_original) %>%
      distinct() %>%
      collect() %>%
      as.data.frame()
    
    # Remove column prefixes
    colnames(out) = sub('.*\\.', '', colnames(out))
    
    out
  
  },
  error=function(e) {
    message(e)
    return(NULL)
  },
  finally={
    dbDisconnect(con)
  }
)
```

```{r, echo = FALSE}
compare = compare_sql_dbplyr()
```
`r compare`

#### df_sql

    # PMID list of interest
    pmid_list <- c('43370', '422270', '422271', '538758', '629888', '731724', '734422', '843463', '843464', '926203')
                # Select columns of interest
    query <- paste0("SELECT distinct e.pmid, b.analyte_name_original, c.dose_level_original, c.dose_level_units_original, ",
                "d.species, b.conc_medium_original, a.time_original, b.time_units_original, a.conc_original, b.conc_units_original ",
                "FROM conc_time_values a ",
                # Join to series table by series ID
                "LEFT JOIN series b on b.id = a.fk_series_id ",
                # Join to studies table by study ID
                "LEFT JOIN studies c on c.id = b.fk_study_id ",
                # Join to subjects table by subject ID
                "LEFT JOIN subjects d on d.id = b.fk_subject_id ",
                # Join to documents table by extraction document ID
                "LEFT JOIN documents e on c.fk_extraction_document_id = e.id ",
                # Filter to PMID of interest
                "WHERE e.pmid in ('",
                # Using paste instead of toString() for cases where identifiers
                # are alphanumeric strings
                paste0(pmid_list, collapse="', '"),
                "')")
    df_sql <- query_db(query = query, 
               con_type = "sqlite")
               
`r DT::datatable(df_sql, list(scrollX = TRUE))`

#### df_dbplyr

    con <- connect_to_db(con_type = "sqlite")

    # Wrapped in a tryCatch so the connection is always closed in case of error
    df_dbplyr <- tryCatch(
      {
    # Store table pointers with column name prefixes
    conc = tbl(con, "conc_time_values") %>% rename_all(function(x) paste0("a.", x))
    series = tbl(con, "series") %>% rename_all(function(x) paste0("b.", x))
    studies = tbl(con, "studies") %>% rename_all(function(x) paste0("c.", x))
    subjects = tbl(con, "subjects") %>% rename_all(function(x) paste0("d.", x))
    docs = tbl(con, "documents") %>% rename_all(function(x) paste0("e.", x))
    
    out <- conc %>%
      left_join(series, 
                by=c("a.fk_series_id"="b.id")) %>%
      left_join(studies, 
                by=c("b.fk_study_id"="c.id")) %>%
      left_join(subjects, 
                by=c("b.fk_subject_id"="d.id")) %>%
      left_join(docs, 
                by=c("c.fk_extraction_document_id"="e.id")) %>%
      filter(e.pmid %in% pmid_list) %>%
      select(e.pmid, b.analyte_name_original, c.dose_level_original, 
             c.dose_level_units_original, d.species, b.conc_medium_original, 
             a.time_original, b.time_units_original, a.conc_original, b.conc_units_original) %>%
      distinct() %>%
      collect() %>%
      as.data.frame()
    
    # Remove column prefixes
    colnames(out) = sub('.*\\.', '', colnames(out))
    
    out
  
      },
      error=function(e) {
        message(e)
    return(NULL)
      },
      finally={
        dbDisconnect(con)
      }
    )

`r DT::datatable(df_dbplyr, list(scrollX = TRUE))`
### {-}

### Pull all data by chemical identifier {.tabset}

```{r, echo = FALSE}
# DTXSID list of interest
dtxsid_list <- c('DTXSID0021383', 'DTXSID2020139', 'DTXSID0020868', 'DTXSID4020533', 'DTXSID0020442')
                # Select columns of interest
query <- paste0("SELECT distinct a.dsstox_substance_id, a.dsstox_casrn, b.radiolabeled, ",
                "c.test_substance_name_original, b.analyte_name_original, d.administration_route_original ",
                "FROM chemicals a ",
                # Join to series table by series ID
                "LEFT JOIN series b on b.fk_analyzed_chemical_id = a.id ",
                # Join to studies table by study ID
                "LEFT JOIN studies c on c.fk_dosed_chemical_id = b.fk_test_chemical_id ",
                # Join to subjects table by subject ID
                "LEFT JOIN administration_route_dict d on d.id = c.fk_administration_route_id ",
                # Filter to PMID of interest
                "WHERE a.dsstox_substance_id in ('",
                # Using paste instead of toString() for cases where identifiers
                # are alphanumeric strings
                paste0(dtxsid_list, collapse="', '"),
                "')")
df_sql <- query_db(query = query, 
               con_type = "sqlite")
```

```{r, echo = FALSE}
con <- connect_to_db(con_type = "sqlite")

# Wrapped in a tryCatch so the connection is always closed in case of error
df_dbplyr <- tryCatch(
  {
    # Store table pointers with column name prefixes
    chemicals = tbl(con, "chemicals") %>% rename_all(function(x) paste0("a.", x))
    series = tbl(con, "series") %>% rename_all(function(x) paste0("b.", x))
    studies = tbl(con, "studies") %>% rename_all(function(x) paste0("c.", x))
    administration_route_dict = tbl(con, "administration_route_dict") %>% 
      rename_all(function(x) paste0("d.", x))
    
    out <- chemicals %>%
      left_join(series, 
                by=c("a.id"="b.fk_analyzed_chemical_id")) %>%
      left_join(studies, 
                by=c("b.fk_test_chemical_id"="c.fk_dosed_chemical_id")) %>%
      left_join(administration_route_dict, 
                by=c("c.fk_administration_route_id"="d.id")) %>%
      filter(a.dsstox_substance_id %in% dtxsid_list) %>%
      select(a.dsstox_substance_id, a.dsstox_casrn, b.radiolabeled, 
             c.test_substance_name_original, b.analyte_name_original, d.administration_route_original) %>%
      distinct() %>%
      collect() %>%
      as.data.frame()
    
    # Remove column prefixes
    colnames(out) = sub('.*\\.', '', colnames(out))
    
    out
  
  },
  error=function(e) {
    message(e)
    return(NULL)
  },
  finally={
    dbDisconnect(con)
  }
)
```

```{r, echo = FALSE}
compare = compare_sql_dbplyr()
```
`r compare`

#### df_sql

    # DTXSID list of interest
    dtxsid_list <- c('DTXSID0021383', 'DTXSID2020139', 'DTXSID0020868', 'DTXSID4020533', 'DTXSID0020442')
                # Select columns of interest
    query <- paste0("SELECT distinct a.dsstox_substance_id, a.dsstox_casrn, b.radiolabeled, ",
                "c.test_substance_name_original, b.analyte_name_original, d.administration_route_original ",
                "FROM chemicals a ",
                # Join to series table by series ID
                "LEFT JOIN series b on b.fk_analyzed_chemical_id = a.id ",
                # Join to studies table by study ID
                "LEFT JOIN studies c on c.fk_dosed_chemical_id = b.fk_test_chemical_id ",
                # Join to subjects table by subject ID
                "LEFT JOIN administration_route_dict d on d.id = c.fk_administration_route_id ",
                # Filter to PMID of interest
                "WHERE a.dsstox_substance_id in ('",
                # Using paste instead of toString() for cases where identifiers
                # are alphanumeric strings
                paste0(dtxsid_list, collapse="', '"),
                "')")
    df_sql <- query_db(query = query, 
               con_type = "sqlite")
               
`r DT::datatable(df_sql, list(scrollX = TRUE))`

#### df_dbplyr

    con <- connect_to_db(con_type = "sqlite")

    # Wrapped in a tryCatch so the connection is always closed in case of error
    df_dbplyr <- tryCatch(
      {
    # Store table pointers with column name prefixes
    chemicals = tbl(con, "chemicals") %>% rename_all(function(x) paste0("a.", x))
    series = tbl(con, "series") %>% rename_all(function(x) paste0("b.", x))
    studies = tbl(con, "studies") %>% rename_all(function(x) paste0("c.", x))
    administration_route_dict = tbl(con, "administration_route_dict") %>% 
      rename_all(function(x) paste0("d.", x))
    
    out <- chemicals %>%
      left_join(series, 
                by=c("a.id"="b.fk_analyzed_chemical_id")) %>%
      left_join(studies, 
                by=c("b.fk_test_chemical_id"="c.fk_dosed_chemical_id")) %>%
      left_join(administration_route_dict, 
                by=c("c.fk_administration_route_id"="d.id")) %>%
      filter(a.dsstox_substance_id %in% dtxsid_list) %>%
      select(a.dsstox_substance_id, a.dsstox_casrn, b.radiolabeled, 
             c.test_substance_name_original, b.analyte_name_original, d.administration_route_original) %>%
      distinct() %>%
      collect() %>%
      as.data.frame()
    
    # Remove column prefixes
    colnames(out) = sub('.*\\.', '', colnames(out))
    
    out
  
      },
      error=function(e) {
    message(e)
    return(NULL)
      },
      finally={
        dbDisconnect(con)
      }
    )

`r DT::datatable(df_dbplyr, list(scrollX = TRUE))`

### {-}